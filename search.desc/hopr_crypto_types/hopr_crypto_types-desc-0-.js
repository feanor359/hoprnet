searchState.loadedDescShard("hopr_crypto_types", 0, "This Rust crate contains implementation common …\nContains error enum implementation used across other …\nImplements ChainKeypair and OffchainKeypair, the important …\nImplements low-level cryptographic primitives, such as …\nImplements basic cryptography related types based on …\nContains small utility functions used in other …\nContains implementation of Verifiable Random Function used …\nContains the error value\nContains the success value\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRepresents a keypair consisting of a secp256k1 private and …\nRepresents a generic key pair The keypair contains a …\nRepresents a keypair consisting of an Ed25519 private and …\nRepresents the type of the public key\nRepresents the type of the private (secret) key\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a keypair from the given secret key.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the public part of the keypair\nGenerates a new random keypair.\nReturns the private (secret) part of the keypair\nConsumes the instance and produces separated private and …\nGeneralization of digest-like operation (MAC, Digest,…) …\nComputation wrapper for a digest that’s compatible with …\nSize of the initialization vector\nSize of the secret key\nLength of the digest in bytes\nRepresents a secret key of fixed length. The value is …\nSimple digest computation wrapper. Use <code>new</code>, <code>update</code> and …\nSimple Message Authentication Code (MAC) computation …\nSimple stream cipher wrapper Use <code>new</code> and <code>apply</code> (or …\nApply keystream to the given data in-place.\nCreates copy of the given data and applies the keystream …\nRetrieve the final digest value and reset this instance so …\nRetrieve the final digest value into a prepared buffer and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAccess to the internal state of the digest-like operation.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new instance of the MAC using the given secret key.\nCreate new instance of the stream cipher initialized with …\nSeeks the keystream to the given block position\nUpdate the internal state of the digest-like using the …\nNatural extension of the Curve Point to the Proof-of-Relay …\nRepresents a compressed serializable extension of the …\nRepresents an elliptic curve point on the secp256k1 curve …\nRepresents a half-key used for Proof of Relay Half-key is …\nRepresents a challenge for the half-key in Proof of Relay. …\nRepresents an Ethereum 256-bit hash value This …\nRepresents an Ed25519 public key.\nRepresents an EdDSA signature using Ed25519 Edwards curve.\nLength of a packet tag\nRepresents a fixed size packet verification tag\nIdentifier of a peer of the network.\nRepresents a secp256k1 public key.\nContains a response upon ticket acknowledgement It is …\nSize of the point if serialized via …\nSize of the compressed public key in bytes\nSize of the point if serialized via …\nSize of the uncompressed public key in bytes\nRepresents an ECDSA signature based on the secp256k1 curve …\nA method that turns all lower-cased hexadecimal address to …\nConverts the curve point into a compressed form. This is a …\nConverts the curve point into an uncompressed form. This …\nSums all given curve points together, creating a new curve …\nSums all given public keys together, creating a new public …\nTakes all the byte slices and computes hash of their …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nParses a <code>PeerId</code> from bytes.\nCreates a curve point from a non-zero scalar. The given …\nDerives the response from two half-keys. This is done by …\nObtains the PoR challenge by adding the two EC points …\nTries to turn a <code>Multihash</code> into a <code>PeerId</code>.\nObtains the PoR challenge by converting the given HalfKey …\nTries to create the public key from a Ed25519 private key. …\nBuilds a <code>PeerId</code> from a public key.\nConvenience method that creates a new hash by hashing this.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts the curve point to a representation suitable for …\nGenerates a random peer ID from a cryptographically secure …\nGenerates random half key, useful for tests.\nGenerates a new random public key. Because the …\nReturns the raw signature, without the encoded public key …\nSigns the given hash using the raw private key.\nSign the given message using the OffchainKeypair.\nSigns the given message using the chain private key.\nConverts the uncompressed representation of the curve …\nConverts the public key to an Ethereum address\nReturns a base-58 encoded string of this <code>PeerId</code>.\nReturns a raw bytes representation of this <code>PeerId</code>.\nSerializes the public key to a binary form.\nConverts the non-zero scalar represented by this half-key …\nConverts this response to the PoR challenge by turning the …\nChecksum of self according to …\nConverts the PoR challenge to an Ethereum challenge. This …\nSerializes the public key to a binary form and converts it …\nOutputs the public key as PeerId represented as Base58 …\nAdds the given public key with <code>tweak</code> times secp256k1 …\nVerifies this signature against the given hash and a …\nVerify this signature of the given message and …\nVerifies this signature against the given message and a …\nLength of the secret value in bytes.\nRepresents a secret value of a fixed length that is …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreates secp256k1 secret scalar from the given bytes. Note …\nGenerates cryptographically strong random secret value.\nCreates X25519 secret scalar (also compatible with Ed25519 …\nConvenience method to XOR one slice onto other.\nBundles values given to the smart contract to prove that a …\nTakes a private key, the corresponding Ethereum address …\nReturns the argument unchanged.\nPerforms a scalar point multiplication of <code>self.h</code> and <code>self.v</code>\nPerforms a scalar point multiplication with the encoded …\nCalls <code>U::from(self)</code>.\nthe pseudo-random point\nVerifies that VRF values are valid")