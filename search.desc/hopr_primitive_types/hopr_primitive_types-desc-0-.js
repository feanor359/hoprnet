searchState.loadedDescShard("hopr_primitive_types", 0, "This crate contains basic types used throughout the entire …\nContains various size-bounded types\nEnumerates all errors in this crate.\nApproximately compares two double-precision floats.\nImplements the most primitive types, such as U256 or …\nObsolete RLP encoding module to be removed in future …\nContains various implementations of Simple Moving Average.\nDefines commonly used traits across the entire code base.\nUnsigned integer (<code>usize</code>) that has an explicit upper bound. …\nWrapper for <code>Vec</code> that has an explicit upper bound on the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nType for any possible error, because the traits in this …\nContains the error value\nListing of some general re-usable errors\nContains the success value\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRepresents an Ethereum address\nRepresents balance of some coin or token.\nRepresents a type of the balance: native or HOPR tokens.\nRepresents and Ethereum challenge. This is a one-way …\nHOPR tokens.\nNative tokens of the underlying chain.\nNumber of digits in the base unit\nCreates Balance of the given <code>amount</code> of this type.\nDeserializes the given amount and creates a new Balance …\nRetrieves the type (symbol) of the balance\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks if the address is all zeroes.\nCreates a new balance given the value and type\nCreates new balance of the given type from the base 10 …\nCreates balance of the given value with the same symbol\nCreates Balance of 1 of this type.\nCreates zero Balance of this type.\nCreates zero balance of the given type\nBasic implementation of Simple Moving Average (SMA).\nSimple Moving Average trait.\nBasic implementation of Simple Moving Average (SMA).\nCalculates the moving average value. Returns <code>None</code> if no …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIndicates whether there are no samples.\nIndicates whether the window is fully occupied with …\nReturns the number of elements in the window. This value …\nCreates an empty SMA instance with the given window size. …\nCreates an empty SMA instance with the given window size. …\nCreates SMA instance given window size and some initial …\nCreates SMA instance given window size and some initial …\nPushes a sample.\nReturns the window size.\nA trait that adds extension method to represent a time …\nRepresents a type that can be encoded to/decoded from a …\nRepresents a type that is already internally represented …\nExtension trait for fixed size numbers to allow conversion …\nSize of the encoded byte array. Defaults to <code>N</code> and should …\nSize of the encoded byte array.\nA trait that adds extension method to perform saturated …\nA generic type that can be converted to a hexadecimal …\nAllows type to be multiplied and divided by a float in …\nRepresents self as <code>Duration</code> since Unix epoch.\nDivide by float in the interval (0.0, 1.0]\nCreate instance from Big Endian bytes. Should panic if …\nTries to parse the type from the hexadecimal …\nCreate instance from Little Endian bytes. Should panic if …\nConvenience function to encode the type into a Box.\nConvenience function to copy this type’s binary …\nConvenience function to represent the A shorthand for …\nMultiply with float in the interval [0.0, 1.0]\nPerforms saturated substraction on <code>SystemTime</code> instances.\nConvert instance to Big Endian bytes.\nHexadecimal representation of this type.\nConvert instance to Little Endian bytes.")