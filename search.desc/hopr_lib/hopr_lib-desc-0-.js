searchState.loadedDescShard("hopr_lib", 0, "HOPR library creating a unified <code>Hopr</code> object that can be …\nRepresents a node announcement entry on the block chain. …\nType of the node account.\nContains acknowledgment information and the respective …\nStatus of the acknowledged ticket.\nRepresents packet acknowledgement\nRepresents an Ethereum address\nNode is announced with a multi-address\nStructure containing data used for on-chain announcement. …\nRepresents the received decrypted packet carrying the …\nRepresents the received decrypted packet carrying the …\nA trait that adds extension method to represent a time …\nA wrapper around <code>HoprState</code> which can be safely shared …\nRepresents balance of some coin or token.\nRepresents a type of the balance: native or HOPR tokens.\nTicket is currently being aggregated in and ongoing …\nTicket is currently being redeemed in and ongoing …\nRepresents a type that can be encoded to/decoded from a …\nRepresents a type that is already internally represented …\nEnumerates all Chain Actions related errors.\nHolds all information about the protocol network to be …\nEnumerates possible changes on a channel entry update\nDescribes a direction of node’s own channel. The …\nOverall description of a channel\nDescribes status of a channel\nThe channel is closed.\nEnumeration of all core type related errors.\nChannel balance has changed\nRepresent a default application tag if none is specified …\nDefault maximum incoming ticket winning probability, above …\nDefault required minimum incoming ticket winning …\nDefault ticket winning probability that will be printed on …\nDNS based host\nWinning probability encoded in 7-byte representation\nTypes of HOPR network environments.\nChannel epoch has changed\nRepresents and Ethereum challenge. This is a one-way …\nTarget is a service directly at the exit node with a given …\nListing of some general re-usable errors\nHigh quality connection to at least 1 public relay and 1 …\nHOPR tokens.\nRepresents a challenge for the half-key in Proof of Relay. …\nNetwork health represented with colors, where green is the …\nHOPR main object providing the entire HOPR node …\nWrapper for incoming Session along with other information …\nEnum differentiator for loop component futures.\nRepresents a keypair consisting of an Ed25519 private and …\nUnique ID of a specific session.\nInterface representing the HOPR server behavior for each …\nRepresents the socket behavior of the hopr-lib spawned <code>Hopr</code>…\nAn enum representing the current state of the HOPR node\nErrors produced by the crate.\nRandom intermediate path with at least the given number of …\nConfiguration of the listening host.\nEnumeration of possible host types.\nNumber of intermediate hops: 3 relayers and 1 destination\nIPv4 based host\nThe other party is initiator of the channel.\nA fixed intermediate path consisting of at most …\nExtension trait for fixed size numbers to allow conversion …\nLists some of the IP protocols.\nHolds the signed binding of the chain key and the packet …\nRepresents a generic key pair The keypair contains a …\nThe lowest possible ticket winning probability due to SC …\nThe maximum number of hops this instance can represent.\nRepresentation of a Multiaddr.\nNative tokens of the underlying chain.\nErrors that can be generated by the crate.\nBasic implementation of Simple Moving Average (SMA).\nNode is not announced.\nThe channel is opened.\nLow quality connection to at least 1 public relay\nOur own node is the initiator of the channel.\nMaximum size of the packet payload in bytes.\nIdentifier of a peer of the network.\nContains either unacknowledged ticket if we’re waiting …\nThe channel is pending to be closed. The timestamp marks …\nErrors generated by the crate.\nThe entire on-chain protocol configuration containing the …\nRepresents the type of the public key\nNo connection, default\nRepresents a winning ticket that can be successfully …\nFrame reassembly\nRepresents routing options in a mixnet with a maximum …\nNumber of digits in the base unit\nInner MTU size of what the HOPR payload can take (payload …\nSize of the encoded byte array. Defaults to <code>N</code> and should …\nSize of the encoded byte array.\nSimple Moving Average trait.\nA trait that adds extension method to perform saturated …\nRepresents the type of the private (secret) key\nFrame segmentation\nCapabilities of a session.\nConfiguration for the session.\nDefines what should happen with the data at the recipient …\nBasic implementation of Simple Moving Average (SMA).\nChannel status has changed\nEnumerates all possible strategies with their respective …\nTags are currently 16-bit unsigned integers\nBloom filter for packet tags to detect packet replays.\nTarget is running over TCP with the given address and port.\nContains the overall description of a ticket with a …\nBuilder for Ticket and VerifiedTicket.\nTicket index has changed\nTicket statistics data exposed by the ticket mechanism.\nA generic type that can be converted to a hexadecimal …\nRepresents a ticket that could be transferred over the wire\nTarget is running over UDP with the given IP address and …\nRepresents a VerifiedTicket with an unknown other part of …\nAllows type to be multiplied and divided by a float in …\nUnknown health, on application startup\nThe ticket is available for redeeming or aggregating\nHolds a ticket that has been already verified. This …\nWe’re waiting for the acknowledgement as a relayer with …\nWe’re waiting for acknowledgement as a sender\nHigh quality connection to at least 1 public relay\nList of all accounts announced on the chain\nObtains the acknowledged challenge out of this …\nVerifies that the given acknowledgement solves this ticket…\nHost on which to listen\nSets channel id based on the <code>source</code> and <code>destination</code>. This, …\ncontract addresses used by the network\nAttempts to aggregate all tickets in the given channel\nList all channels\nGet peers connected peers with quality higher than some …\nGet all tickets\nSets the ticket amount. This or TicketBuilder::balance …\nAmount of HOPR tokens this ticket is worth. Always between …\naddress of contract that manages transport announcements …\nRepresents self as <code>Duration</code> since Unix epoch.\nCalculates the moving average value. Returns <code>None</code> if no …\nSets the ticket amount as HOPR balance. This or …\nCreates Balance of the given <code>amount</code> of this type.\nDeserializes the given amount and creates a new Balance …\nRetrieves the type (symbol) of the balance\nVerifies all inputs and builds the Ticket. This <strong>does not</strong> …\nValidates all inputs and builds the VerifiedTicket by …\nValidates all input and builds the VerifiedTicket by …\nIdentifies whether a loop is allowed to finish or should …\nCapabilities of this Session.\nCapabilities offered by the session.\nmust match one of the Network.id\nCreates a pipeline that chains the indexer-generated data, …\nSets the EthereumChallenge for Proof of Relay. Must be set.\nRepresent the Proof of Relay challenge encoded as Ethereum …\nGet the channel entry between source and destination node. …\nChannel domain separator used to compute the VRF …\nSets the channel epoch. Must be less or equal to 2^24. …\nEpoch of the channel this ticket belongs to. Always …\nGet the channel entry from Hash. @returns the channel …\nSets the channel id. This, TicketBuilder::addresses or …\nChannel ID. See generate_channel_id for how this value is …\nHoprChannels contract address, implementation of mixnet …\nList all channels open from a specified Address\nList all channels open to a specified address\nCheck if packet tag is in the Bloom filter. False …\nChecks and sets a packet tag (if not present) in a single …\nReturns the earliest time the channel can transition from …\nChecks if the closure time of this channel has passed. …\nStores a value into the atomic if the current value is the …\nStores a value into the atomic if the current value is the …\nStores a value into the atomic if the current value is the …\nConfiguration related public types\nnumber of follow-on blocks required until a block is …\nVarious public constants.\nIf the node has announced, did it announce with routing …\nReturns the current number of items in this Bloom filter.\nReturns the number of hops this instance represents. This …\nDecapsulates the multiaddress (= strips the /p2p/&lt;peer_id&gt; …\nReturn …\nReturn <code>ChannelStatus::Closed</code>\nCompares the two given channels and returns a vector of …\nSets channel id based on the <code>source</code> and <code>destination</code>. This, …\nDetermines the channel direction given the self address. …\nDivide by float in the interval (0.0, 1.0]\nCreate a new, empty multiaddress.\nEncoded winning probability represented via 56-bit number.\nChecks whether the given <code>Multiaddr</code> is a suffix of this …\nEnumerates all errors thrown from this library.\nApproximately compares two double-precision floats.\nEncodes [0.0f64, 1.0f64] to [0x00000000000000, …\nConvert a Multiaddr to a string\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate instance from Big Endian bytes. Should panic if …\nParses a <code>PeerId</code> from bytes.\nTries to parse the type from the hexadecimal …\nCreate instance from Little Endian bytes. Should panic if …\nTries to turn a <code>Multihash</code> into a <code>PeerId</code>.\nRe-construct binding from the chain key and packet key, …\nBuilds a <code>PeerId</code> from a public key.\nCreates a keypair from the given secret key.\nReads the protocol config JSON file and returns it\nGenerates channel ID hash from <code>source</code> and <code>destination</code> …\nGets the value of the atomic without performing an atomic …\nComputes Ethereum signature hash of the ticket, must be …\nGenerates the channel ID using the source and destination …\nGets the current indexer state: last indexed block ID and …\nGet minimum incoming ticket winning probability\nBased on the price of this ticket, determines the path …\nGet the list of all announced public nodes in the network\nGet ticket price\nIs the node announced?\nID of this Session.\nSets the ticket index. Must be less or equal to 2^48. …\nTicket index. Always between 0 and 2^48.\nSets the index offset. Must be greater or equal 1. …\nTicket index offset. Always between 1 and 2^32. For normal …\nblock number to start the indexer from\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nShorthand to acknowledge the ticket if the matching …\nConvenience function to encode the type into a Box.\nConvenience function to copy this type’s binary …\nConvenience function to represent the A shorthand for …\nConsumes the atomic and returns the contained value.\nTransforms this ticket into RedeemableTicket that can be …\nAttempts to transform this ticket back into a …\nShorthand for transforming this ticket into …\nCreates new unacknowledged ticket from the VerifiedTicket, …\nInverts the intermediate path if this is an instance of …\nReturns true if this ticket aggregates multiple tickets.\nTest whether the peer with PeerId is allowed to access the …\nIndicates whether there are no samples.\nReturns true if the length of this multiaddress is 0.\nIndicates whether the window is fully occupied with …\nChecks if this ticket is considered a win. Requires access …\nChecks if this acknowledged ticket is winning.\nChecks if the address is all zeroes.\nReturns the components of this multiaddress.\nDeconstructs self back into the unverified Ticket.\nReturns the number of elements in the window. This value …\nReturn the length in bytes of this multiaddress.\nList all multiaddresses on which the node is listening\nLoads a value from the atomic.\nList all multiaddresses announced by this node\nCheck whether the string looks like a valid domain.\nmaximum block range to fetch while indexing logs\nOwn PeerId used in the libp2p transport layer\ncontract address of Safe capability module implementation\nMultiply with float in the interval [0.0, 1.0]\nReturns the multiaddress associated with this announcement.\nList all multiaddresses announced on-chain for the given …\nList all peers connected to this\nGet measured network health\nList all multiaddresses observed for a PeerId\nGet all data collected from the network relevant for a …\naddress of contract that manages authorization to access …\naddress of contract that maps to the requirements that …\nCreate and sign new key binding of the given chain key and …\nConstructs structure from multiaddress and optionally also …\nCreates a new balance given the value and type\nCreates an empty SMA instance with the given window size. …\nCreates an empty SMA instance with the given window size. …\nCreates a new atomic <code>HoprState</code>.\nCreates new balance of the given type from the base 10 …\nCreates SMA instance given window size and some initial …\nCreates SMA instance given window size and some initial …\naddress of contract that maps between Safe instances and …\nfactory contract to produce Safe instances\nCreates balance of the given value with the same symbol\nCreates Balance of 1 of this type.\nDetermines the channel’s direction and counterparty …\nThe fixed path options for the session.\nThe peer to which the session should be established.\nPing another node in the network based on the PeerId\nPops the last <code>Protocol</code> of this multiaddr, or <code>None</code> if the …\nListening TCP or UDP port (mandatory).\nFully process a single HOPR session\nReturns &amp;str identifiers for the protocol names themselves.\nReturns the public part of the keypair\nPushes a sample.\nAdds an already-parsed address component to the end of …\nGenerates a new random keypair.\nGenerates a random peer ID from a cryptographically secure …\nGenerates random, but still a valid acknowledgement.\nCalculates the remaining channel closure grace period. …\nReplace a <code>Protocol</code> at some position in this <code>Multiaddr</code>.\nReset the ticket metrics to zero\nSolution to the PoR challenge in the ticket.\nObsolete RLP encoding module to be removed in future …\nRouting options used to deliver data.\nCurrent safe allowance balance\nPerforms saturated substraction on <code>SystemTime</code> instances.\nReturns the private (secret) part of the keypair\nSend a message to another peer in the network\nActual incoming session.\nSets the value of the atomic without performing an atomic …\nPuts a packet tag into the Bloom filter\nSigns the ticket using the given private key, turning this …\nSet the signature of this ticket. Defaults to <code>None</code>.\nECDSA secp256k1 signature of all the above values.\nStores a value into the atomic.\nReturns a list of environments which the node is able to …\nStores a value into the atomic, returning the previous …\nStores a value into the atomic, returning the previous …\nDesired target of the data received over the session.\nTarget of the session.\nProtocol to be used to connect to the target\nVerified ticket that can be redeemed.\naddress of contract that allows Hopr Association to …\nGet statistics for all tickets\nGet all tickets in a channel specified by Hash\nReturns a base-58 encoded string of this <code>PeerId</code>.\nConvert instance to Big Endian bytes.\nReturns a raw bytes representation of this <code>PeerId</code>.\nChecksum of self according to …\nHexadecimal representation of this type.\nConvert instance to Little Endian bytes.\nReturn a copy of this <code>Multiaddr</code>’s byte representation.\nHopr token contract address\nConvenience function to copy data in both directions …\nmilliseconds between polling the RPC for new transactions\nConsumes the instance and produces separated private and …\nUsed to either set a PRN or revoke being a PRN\nGets the block number of the announcement if this peer ID …\nValidates the acknowledgement.\nFixed ticket hash that is guaranteed to be equal to …\nVerified issuer of the ticket. The returned address is …\nShorthand to retrieve reference to the verified ticket …\nTicket with already verified signature.\nConvenience method to retrieve a reference to the …\nConvenience method to retrieve a reference to the …\nConvenience method to retrieve a reference to the …\nVerifies the signature of this ticket, turning this ticket …\nNode.js-fashioned semver string\nVRF parameters required for redeeming.\nSets the ticket winning probability. Mutually exclusive …\nReturns the decoded winning probability of the ticket\nReturns the verified encoded winning probability of the …\nSets the encoded ticket winning probability. Mutually …\nDecodes [0x00000000000000, 0xffffffffffffff] to [0.0f64, …\nReturns the window size.\naddress of contract that allows Hopr Association to …\nLike <code>Multiaddr::push</code> but consumes <code>self</code>.\nCreate a new, empty multiaddress with the given capacity.\nAppends the given <code>PeerId</code> if not yet present at the end of …\nWithdraw on-chain assets to a given address @param …\nCreates zero Balance of this type.\nCreates zero balance of the given type\nInitializes the builder for a zero hop ticket.\nDNS based host\nConfiguration for the Heartbeat mechanism\nConfiguration of the listening host.\nEnumeration of possible host types.\nIPv4 based host\nConfiguration for the <code>crate::network::Network</code> object\nConfiguration of the P2P protocols.\nAn alias for strategy configuration type.\nConfiguration of the physical transport mechanism.\nHost on which to listen\nIndicate whether the <code>MultiStrategy</code> can contain another …\nWhen true, assume that the node is running in an isolated …\nBlockchain specific configuration\nPath to the directory containing the database\nConfiguration of the underlying database engine\nReturn …\nReturn …\nReturn …\nReturn …\nReturn …\nReturn …\nReturn …\nExecution interval of the configured strategies in seconds.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>heartbeat</code> protocol config\nConfiguration of the protocol heartbeat mechanism\nConfiguration related to host specifics\nInterval in which the heartbeat is triggered in seconds\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaximum delay\nMinimum delay will be multiplied by backoff, it will be …\nConfiguration of network properties\nDetermines if the strategy should continue executing the …\nWinning probability that gets printed on any outgoing …\nListening TCP or UDP port (mandatory).\nWhen true, assume a testnet with multiple nodes running on …\nConfiguration specific to protocol execution on the p2p …\nConfiguration of the <code>Safe</code> mechanism\nConfiguration of individual sub-strategies.\nConfiguration of underlying node behavior in the form …\nThe time interval for which to consider peer heartbeat …\n<code>ticket_aggregation</code> protocol config\nConfiguration specific to transport mechanics\nValidates the HostConfig to be used as an external host\nRound-to-round variance to complicate network sync in …\nApplication version as presented externally using the …\nApplication version coerced into the <code>major</code>.<code>minor</code>.<code>patch</code> form\nMinimum native token balance to start the node.\nBalance that is suggested for funding the node the first …\nContains the error value\nEnumeration of errors thrown from this library.\nEnumeration of status errors thrown from this library.\nContains the success value\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")