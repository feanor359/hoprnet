searchState.loadedDescShard("hopr_crypto_sphinx", 0, "This Rust crate contains implementation of the Sphinx …\nContains simple key derivation functions for different …\nImplementations of <code>SphinxSuite</code> trait for different …\nImplementation of the Lioness wide-block cipher using …\nImplementation of the SPHINX header format\nDerivation of shared keys for SPHINX header\nSize of the nonce in the Ping sub protocol\nCalculates a message authentication code with fixed key …\nUsed in Proof of Relay to derive the half-key of for the …\nDerives the commitment seed given the compressed private …\nDerives a key for MAC calculation by expanding the given …\nUsed in Proof of Relay to derive own half-key (S0) The …\nDerives the packet tag used during packet construction by …\nDerives a ping challenge (if no challenge is given) or a …\nSample a random secp256k1 field element that can represent …\nRepresents an instantiation of the Sphinx protocol using …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nImplementation of Pseudo-Random Permutation (PRP). …\nParameters for the Pseudo-Random Permutation (PRP) function\nApplies forward permutation on the given plaintext and …\nApplies forward permutation on the given plaintext and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new PRP instance using the given parameters\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nApplies inverse permutation on the given plaintext and …\nApplies inverse permutation on the given ciphertext and …\nCreates new parameters for the PRP by expanding the given …\nCreates new instance of the PRP using the raw key and IV.\nPacket is at its final destination\nEnum carry information about the packet based on whether …\nPacket is supposed to be relayed\nCarries routing information for the mixnet packet.\nApplies the forward transformation to the header. If the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the size of the packet header given the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates the routing information of the mixnet packet\nAdditional data for the final destination\nAdditional data for the relayer\nTransformed header\nAuthentication tag\nPublic key of the next node\nPosition of the relay in the path\nRepresents the Alpha value of a certain length in the …\nLength of the Alpha value - a binary representation of the …\nScalar type supported by the EC group\nEC group element\nGeneric additive abelian group element with an associated …\nKeypair corresponding to the EC group\nTypes representing a valid non-zero scalar an additive …\nStructure containing shared keys for peers using the …\nRepresents a shared secret with a remote peer.\nRepresents an instantiation of the Spinx protocol using …\nPerforms KDF expansion from the given group element using …\nExtract a keying material from a group element using HKDF …\nCalculates the forward transformation for the given the …\nReturns the argument unchanged.\nConverts the group element from the binary format …\nCreate scalar from bytes\nCreate a group element using the group generator and the …\nGenerates shared secrets given the group element of the …\nCalls <code>U::from(self)</code>.\nGroup element is considered valid if it is not a neutral …\nConvenience function to generate shared keys from the path …\nGenerates a random scalar using a cryptographically secure …\nGenerates a random pair of group element and secret scalar.\nConverts the group element to a binary format suitable for …\nConvert scalar to bytes.")