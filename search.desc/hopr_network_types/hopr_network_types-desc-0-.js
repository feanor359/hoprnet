searchState.loadedDescShard("hopr_network_types", 0, "Contains all errors thrown from this crate.\nContains implementation of a <code>Session</code> message protocol.\nContains various networking-related types\nContains UDP socket-related helpers.\nVarious network IO-related utilities\nContains the error value\nContains the success value\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nData frame of arbitrary length. The frame can be segmented …\nID of a Frame.\nContains information about a frame that being built. The …\nRepresents a frame reassembler.\nSize of the segment header.\nRepresents a frame segment. Besides the data, a segment …\nConvenience type that identifies a segment within a frame.\nCloses the reassembler. Any subsequent calls to …\nFrame data.\nData in this segment.\nAccording to the max_age set during construction, evicts …\nIdentifier of this frame.\nID of the Frame this segment belongs to.\nID of the frame.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the SegmentId for this segment.\nReturns information about the incomplete frames. The …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTransform self into iterator of missing segment numbers.\nTime of the last received segment in this frame.\nIndices of segments that are missing. Empty if the frame …\nCreates a new frame reassembler and a corresponding stream …\n<code>Session</code> protocol messages\nPushes a new Segment for reassembly. This function also …\nSegments this frame into a list of segments each of …\nIndex of this segment within the segment sequence.\nTotal number of segments within this segment sequence.\n<code>Session</code> protocol state machine\nThe total number of segments in this frame.\nContains the error value\nContains the success value\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRepresents a message containing frame acknowledgements.\nRepresents a message containing frame acknowledgements.\nSize of a single segment retransmission request entry.\nHolds the Frame Acknowledgement message. This carries an …\nHeader size of the session message. This is currently the …\nMaximum number of frame IDs that can be accommodated.\nMaximum number of segment retransmission entries.\nMaximum number of missing segments per frame.\nMaximum number of segments per frame.\nRepresents a message containing a request for segments.\nRepresents a message containing a request for segments.\nRepresents a message containing a segment.\nRepresents a message containing a segment.\nIterator over <code>SegmentId</code> in <code>SegmentRequest</code>.\nHolds the Segment Retransmission Request message. That is …\nContains all messages of the Session sub-protocol.\nAuto-generated discriminant enum variants\nCurrent version of the protocol.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTry to create Self from the raw representation\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvenience method to encode the session message.\nReturns true if there are no segments to retransmit in …\nReturns true if there are no frame IDs in this instance.\nIndicates whether the maximum number of frame IDs has been …\nReturns the number of segments to retransmit.\nNumber of acknowledged frame IDs in this instance.\nReturns the minimum size of a SessionMessage.\nPushes the frame ID. Returns true if the value has been …\nEnable frame acknowledgement by the recipient.\nMaximum number of bytes that can be written in a single …\nPayload capacity is MTU minus the sizes of the Session …\nEnable requesting of incomplete frames by the recipient.\nEnable frame retransmission by the sender. This requires …\nConfiguration of Session protocol.\nRepresents individual Session protocol features that can …\nRepresents a socket for a session between two nodes bound …\nContains the cloneable state of the session bound to a …\nSize of the buffer for acknowledged frame IDs.\nBase for the exponential backoff on retries.\nReturn …\nSet of features that should be enabled on this Session.\nSpecifies the maximum period a frame should be kept by the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaximum number of buffered segments.\nOptional rate limiting of egress messages per second. This …\nCreate a new socket over the given underlying <code>transport</code> …\nIf a frame is incomplete (on the receiver), retransmission …\nIf a frame is unacknowledged (on the sender), entire frame …\nStandard deviation of a Gaussian jitter applied to …\nSegments the <code>data</code> and sends them as (possibly multiple) …\nReturns the ID of this session.\nGets the state of this socket.\nGets the mutable state of this socket.\nDNS name and port.\nRandom intermediate path with at least the given number of …\nA fixed intermediate path consisting of at most …\nIP address with port.\nImplements a host name with port. This could be either a …\nLists some of the IP protocols.\nThe maximum number of hops this instance can represent.\nRepresents routing options in a mixnet with a maximum …\nReturns the number of hops this instance represents. This …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the unresolved DNS name or IP address as string.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInverts the intermediate path if this is an instance of …\nChecks if this instance is a DNS name.\nChecks if this instance is an IP address and whether it is …\nChecks if this instance is an IP address and whether it is …\nChecks if this instance is an IP address and whether it is …\nGets the port number.\nTries to resolve the DNS name and returns all IP addresses …\nTries to resolve the DNS name and returns all IP addresses …\nTries to resolve the DNS name and returns all IP addresses …\nForeign data are accepted as if they arrived from the set …\nMimics TCP-like stream functionality on a UDP socket by …\nForeign data are simply discarded.\nError is raised on the <code>poll_read</code> attempt.\nDefines what happens when data from another <code>SocketAddr</code> …\nBuilder object for the <code>ConnectedUdpStream</code>.\nLocal address that all UDP sockets in this instance are …\nBuilds the <code>ConnectedUdpStream</code> with UDP socket(s) bound to …\nCreates a new builder.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe size of the UDP receive buffer.\nSets the expected counterparty for data sent/received by …\nDefines the behavior when data from an unexpected source …\nSets how many parallel readers/writer sockets should be …\nSize of the TX/RX queue that dispatches data of reads …\nThis is a proper re-implementation of Tokio’s …")